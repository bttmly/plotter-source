// Generated by CoffeeScript 1.7.1
(function() {
  var gebi, gebn, inc, qs, qsa, slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  slice = Function.prototype.call.bind(Array.prototype.slice);

  qs = document.querySelector.bind(document);

  gebi = document.getElementById.bind(document);

  gebn = function(name) {
    return slice(document.getElementsByName(name));
  };

  qsa = function(selector, context) {
    if (context == null) {
      context = document;
    }
    if (typeof context === "string") {
      context = document.querySelector(context);
    }
    return slice(context.querySelectorAll(selector));
  };

  inc = function() {
    var i;
    i = 0;
    return function() {
      return ++i;
    };
  };

  test("Value Object", function() {
    var check, mixedControls, select, text, values;
    mixedControls = Controls("#mixed-controls");
    check = qs("#mixed-controls [type='checkbox']");
    text = qs("#mixed-controls [type='text']");
    select = qs("#mixed-controls select");
    check.checked = true;
    text.value = "text";
    values = mixedControls.value();
    equal(JSON.stringify(values.normal()), JSON.stringify([
      {
        id: "mixedCheck",
        value: "check"
      }, {
        id: "mixedText",
        value: "text"
      }, {
        id: "mixedSelect",
        value: "option3"
      }
    ]), ".normal() looks good, and .serialize() by extension");
    equal(JSON.stringify(values.valueArray()), JSON.stringify(["check", "text", "option3"]), ".valueArray() looks good");
    equal(JSON.stringify(values.idArray()), JSON.stringify(["mixedCheck", "mixedText", "mixedSelect"]), ".idArray() looks good");
    equal(JSON.stringify(values.idValuePair()), JSON.stringify({
      "mixedCheck": "check",
      "mixedText": "text",
      "mixedSelect": "option3"
    }), ".idValuePair() looks good");
    equal(values.valueString(), "check, text, option3", ".valueString() default looks good");
    equal(values.valueString("---"), "check---text---option3", "valueString() with custom delimiter looks good");
    equal(values.at(1), "text", ".at() looks good called with number");
    equal(values.at("mixedText"), "text", ".at() looks good called with a string");
    equal(values.first(), "check", ".first() looks good");
    equal(values.last(), "option3", ".last() looks good");
    equal(JSON.stringify(values.valueArrayOne()), JSON.stringify(values.valueArray()), ".idArrayOne() with length > 1 looks good");
    equal(JSON.stringify(values.idArrayOne()), JSON.stringify(values.idArray()), ".idArrayOne() with length > 1 looks good");
    check.checked = false;
    text.value = "";
    equal(mixedControls.value().valueArrayOne(), "option3", ".valueArrayOne() with length === 1 looks good");
    equal(mixedControls.value().idArrayOne(), "mixedSelect", ".idArrayOne() with length === 1 looks good");
    equal(mixedControls.filter("input").value().valueArrayOne(), void 0, ".valueArrayOne with length === 0 looks good");
    return equal(mixedControls.filter("input").value().idArrayOne(), void 0, ".idArrayOne() with length === 0 looks good");
  });

  test("Valid", function() {
    var allowed, allowedFalse, alphanumeric, alphanumericFalse, checks, composed, email, emailFalse, isValue, isValueFalse, lengthBetween, lengthBetweenFalse, lengthIs, lengthIsFalse, lengthMax, lengthMaxFalse, lengthMin, lengthMinFalse, letters, lettersFalse, list, listFalse, notAllowed, notAllowedFalse, notEmpty, notEmptyFalse, notEmptyTrim, notEmptyTrimFalse, numberBetween, numberBetweenFalse, numberMax, numberMaxFalse, numberMin, numberMinFalse, numeric, numericFalse, phone, phoneFalse, radios;
    notEmpty = gebi("notEmpty");
    notEmptyTrim = gebi("notEmptyTrim");
    numeric = gebi("numeric");
    alphanumeric = gebi("alphanumeric");
    letters = gebi("letters");
    isValue = gebi("isValue");
    phone = gebi("phone");
    email = gebi("email");
    list = gebi("list");
    allowed = gebi("allowed");
    notAllowed = gebi("notAllowed");
    numberBetween = gebi("numberBetween");
    numberMax = gebi("numberMax");
    numberMin = gebi("numberMin");
    lengthBetween = gebi("lengthBetween");
    lengthMax = gebi("lengthMax");
    lengthMin = gebi("lengthMin");
    lengthIs = gebi("lengthIs");
    equal(Controls.validate(notEmpty), true, "'notEmpty' validation true as expected");
    equal(Controls.validate(notEmptyTrim), true, "'notEmptyTrim' validation true as expected");
    equal(Controls.validate(numeric), true, "'numeric' validation true as expected");
    equal(Controls.validate(alphanumeric), true, "'alphanumeric' validation true as expected");
    equal(Controls.validate(letters), true, "'letters' validation true as expected");
    equal(Controls.validate(isValue), true, "'isValue' validation true as expected");
    equal(Controls.validate(phone), true, "'phone' validation true as expected");
    equal(Controls.validate(email), true, "'email' validation true as expected");
    equal(Controls.validate(list), true, "'list' validiation true as expected");
    equal(Controls.validate(allowed), true, "'allowed' validation true as expected");
    equal(Controls.validate(notAllowed), true, "'notAllowed' validation true as expected");
    equal(Controls.validate(numberBetween), true, "'numberBetween' validation true as expected");
    equal(Controls.validate(numberMax), true, "'numberMax' validation true as expected");
    equal(Controls.validate(numberMin), true, "'numberMin' validation true as expected");
    equal(Controls.validate(lengthBetween), true, "'lengthBetween' validation true as expected");
    equal(Controls.validate(lengthMax), true, "'lengthMax' validation true as expected");
    equal(Controls.validate(lengthMin), true, "'lengthMin' validation true as expected");
    equal(Controls.validate(lengthIs), true, "'lengthIs' validation true as expected");
    notEmptyFalse = gebi("notEmptyFalse");
    notEmptyTrimFalse = gebi("notEmptyTrimFalse");
    numericFalse = gebi("numericFalse");
    alphanumericFalse = gebi("alphanumericFalse");
    lettersFalse = gebi("lettersFalse");
    isValueFalse = gebi("isValueFalse");
    phoneFalse = gebi("phoneFalse");
    emailFalse = gebi("emailFalse");
    listFalse = gebi("listFalse");
    allowedFalse = gebi("allowedFalse");
    notAllowedFalse = gebi("notAllowedFalse");
    numberBetweenFalse = gebi("numberBetweenFalse");
    numberMaxFalse = gebi("numberMaxFalse");
    numberMinFalse = gebi("numberMinFalse");
    lengthBetweenFalse = gebi("lengthBetweenFalse");
    lengthMaxFalse = gebi("lengthMaxFalse");
    lengthMinFalse = gebi("lengthMinFalse");
    lengthIsFalse = gebi("lengthIsFalse");
    equal(Controls.validate(notEmptyFalse), false, "'notEmpty' validation false as expected");
    equal(Controls.validate(notEmptyTrimFalse), false, "'notEmptyTrim' validation false as expected");
    equal(Controls.validate(numericFalse), false, "'numeric' validation false as expected");
    equal(Controls.validate(alphanumericFalse), false, "'alphanumeric' validation false as expected");
    equal(Controls.validate(lettersFalse), false, "'letters' validation false as expected");
    equal(Controls.validate(isValueFalse), false, "'isValue' validation false as expected");
    equal(Controls.validate(phoneFalse), false, "'phone' validation false as expected");
    equal(Controls.validate(emailFalse), false, "'email' validation false as expected");
    equal(Controls.validate(listFalse), false, "'list' validation false as expected");
    equal(Controls.validate(allowedFalse), false, "'allowed' validation false as expected");
    equal(Controls.validate(notAllowedFalse), false, "'notAllowed' validation false as expected");
    equal(Controls.validate(numberBetweenFalse), false, "'numberBetween' validation false as expected");
    equal(Controls.validate(numberMaxFalse), false, "'numberMax' validation false as expected");
    equal(Controls.validate(numberMinFalse), false, "'numberMin' validation false as expected");
    equal(Controls.validate(lengthBetweenFalse), false, "'lengthBetween' validation false as expected");
    equal(Controls.validate(lengthMaxFalse), false, "'lengthMax' validation false as expected");
    equal(Controls.validate(lengthMinFalse), false, "'lengthMin' validation false as expected");
    equal(Controls.validate(lengthIsFalse), false, "'lengthIs' validation false as expected");
    radios = gebn("radio");
    equal(Controls.validate(radios[0]), false, "Radio should not validate if none matching it's name are checked");
    radios[0].checked = true;
    equal(Controls.validate(radios[0]), true, "Radio should validate if it itself is checked");
    equal(Controls.validate(radios[1]), true, "Radio should validate if another radio matching it's name is checked");
    checks = gebn("checkbox");
    equal(Controls.validate(checks[0]), true, "Checkbox should by default validate if none matching it's name are checked");
    equal(Controls.validate(checks[1]), false, "Checkbox should not validate if <= 'min' matching it's name are checked");
    checks[0].checked = true;
    equal(Controls.validate(checks[1]), true, "Checkbox should validate if >= 'min' matching it's name are checked");
    equal(Controls.validate(checks[2]), true, "Checkbox should validate if <= 'max' matching it's name are checked");
    checks[1].checked = true;
    equal(Controls.validate(checks[2]), false, "Checkbox should not validate if >= 'max' matching it's name are checked");
    composed = gebi("composed1");
    equal(Controls.validate(composed), false, "Composed validation should fail if none match");
    composed.value = 1234567890;
    equal(Controls.validate(composed), false, "Composed validation should fail if any don't match");
    composed.value = 123456;
    return equal(Controls.validate(composed), true, "Composed validation should succeed only if all match");
  });

  test("Filtering", function() {
    var check, justCheck, justSelect, mixedControls, noCheck, noSelect, select, tagInput, typeText;
    mixedControls = Controls("#mixed-controls");
    check = qs("#mixed-controls [type='checkbox']");
    select = qs("#mixed-controls select");
    noCheck = mixedControls.not("[type='checkbox']");
    noSelect = mixedControls.not(function(control) {
      return control.tagName.toLowerCase() === "select";
    });
    equal(noCheck.length, 2, ".not() rejects controls by selector.");
    equal(__indexOf.call(noCheck, check) < 0, true, "Rejected item removed by selector.");
    equal(noSelect.length, 2, ".not() rejects controls by test function.");
    equal(__indexOf.call(noSelect, select) < 0, true, "Rejected item removed by test function.");
    justCheck = mixedControls.filter("[type='checkbox']");
    justSelect = mixedControls.filter(function(control) {
      return control.tagName.toLowerCase() === "select";
    });
    equal(justCheck.length, 1, ".filter() keeps controls by selector.");
    equal(justCheck[0], check, "Kept control by selector");
    equal(justSelect.length, 1, ".filter() keeps controls by test function.");
    equal(justSelect[0], select, "Kept control by test function.");
    tagInput = mixedControls.tag("input");
    equal(tagInput.every(function(e) {
      return e.tagName.toLowerCase() === "input";
    }), true, ".tag() filters controls by tag");
    typeText = mixedControls.type("text");
    return equal(typeText.every(function(e) {
      return e.type.toLowerCase() === "text";
    }), true, ".type() filters controls by type");
  });

  test("Clear", function() {
    var check, mixedControls, select, text;
    mixedControls = Controls("#mixed-controls");
    check = qs("#mixed-controls [type='checkbox']");
    text = qs("#mixed-controls [type='text']");
    select = qs("#mixed-controls select");
    check.checked = true;
    text.value = "text value";
    select[2].selected = true;
    equal(check.checked, true, "Checkbox starts checked.");
    equal(text.value, "text value", "Text input starts with value.");
    equal(select.selectedIndex, 2, "Select starts with third option selected");
    mixedControls.clear();
    equal(check.checked, false, "Checkbox unchecked after clear.");
    equal(text.value, "", "Text input value is '' after clear.");
    return equal(select.selectedIndex, 0, "First select option selected after clear.");
  });

  test("Property setting", function() {
    var check, mixedControls, select, text, timesChanged;
    mixedControls = Controls("#mixed-controls");
    check = qs("#mixed-controls [type='checkbox']");
    text = qs("#mixed-controls [type='text']");
    select = qs("#mixed-controls select");
    equal(mixedControls.every(function(c) {
      return !c.disabled;
    }), true, "All controls initially not disabled");
    mixedControls.disabled(true);
    equal(mixedControls.every(function(c) {
      return c.disabled;
    }), true, "All controls disabled after .disabled( true )");
    mixedControls.disabled(false);
    equal(mixedControls.every(function(c) {
      return !c.disabled;
    }), true, "All controls enabled again after .disabled( false )");
    equal(mixedControls.every(function(c) {
      return !c.required;
    }), true, "All controls initially not required");
    mixedControls.required(true);
    equal(mixedControls.every(function(c) {
      return c.required;
    }), true, "All controls required after .required( true )");
    mixedControls.required(false);
    equal(mixedControls.every(function(c) {
      return !c.required;
    }), true, "All controls not required again after .required( false )");
    timesChanged = 0;
    mixedControls.on("change", function(evt) {
      console.log(evt.target);
      return ++timesChanged;
    });
    equal(check.checked, false, "Checkbox initially unchecked");
    mixedControls.checked(true);
    mixedControls.checked(true);
    equal(check.checked, true, "Checkbox checked after .checked( true )");
    equal(timesChanged, 1, "Using .checked( true ) triggers a change event only if checked changes");
    equal((__indexOf.call(text, "checked") >= 0), false, "No 'checked' property added to other types of inputs.");
    mixedControls.checked(false);
    mixedControls.checked(false);
    equal(check.checked, false, "Checkbox again unchecked after .checked( false )");
    return equal(timesChanged, 2, "Using checked( false ) triggers a change event only if checked changes");
  });

  test("Events", function() {
    var changeHeard, clicks, correctContext, handler, mixedControls, text, textCtl, v, validHeard;
    mixedControls = Controls("#mixed-controls");
    text = qs("#mixed-controls [type='text']");
    changeHeard = false;
    correctContext = false;
    handler = mixedControls.on("change", function(event) {
      changeHeard = !changeHeard;
      if (this === mixedControls) {
        return correctContext = true;
      }
    });
    mixedControls[0].dispatchEvent(new Event("change", {
      bubbles: true
    }));
    equal(changeHeard, true, ".on() attaches event listener");
    equal(correctContext, true, "Handler bound to control collection");
    mixedControls.off("change", handler);
    mixedControls[0].dispatchEvent(new Event("change", {
      bubbles: true
    }));
    equal(changeHeard, true, ".off() removes event listener");
    clicks = inc();
    v = void 0;
    mixedControls.on("click", function(event) {
      return v = clicks();
    });
    mixedControls.trigger("click");
    equal(v, 1, ".trigger() works for event triggering");
    equal(mixedControls._eventListeners.click.length, 1, "_eventListeners holds references to listeners");
    mixedControls.offAll("click");
    mixedControls.trigger("click");
    equal(v, 1, ".offAll() removes events");
    textCtl = mixedControls.filter("[type='text']");
    textCtl.valid = function() {
      return true;
    };
    validHeard = false;
    textCtl.on("valid", function(event) {
      return validHeard = true;
    });
    textCtl.trigger("change");
    return equal(validHeard, true, "automatic 'valid' event triggering working");
  });

  test("Misc.", function() {
    var clickHeard, colLabels, labels, mixedControls, response, text1;
    text1 = Controls("#text1");
    clickHeard = false;
    text1.on("click", function(event) {
      return clickHeard = true;
    });
    text1.invoke("click");
    equal(clickHeard, true, "Invoking 'click' triggers listeners");
    mixedControls = Controls("#mixed-controls");
    response = [];
    mixedControls.invoke(function() {
      return response.push("invoked");
    });
    equal(JSON.stringify(response), JSON.stringify(["invoked", "invoked", "invoked"]), "Passing functions to invoke works.");
    response = [];
    mixedControls.invoke(function() {
      return response.push(this.id);
    });
    equal(JSON.stringify(response), JSON.stringify(["mixedCheck", "mixedText", "mixedSelect"]), "Functions are invoked in the context of the control DOM element.");
    labels = qsa("label", "#mixed-controls");
    colLabels = mixedControls.labels();
    return equal(labels.length === colLabels.length && labels.every(function(label) {
      return __indexOf.call(colLabels, label) >= 0;
    }), true, "Labels gets labels of collection's controls");
  });

  test("External", function() {
    var a, b, c, d, e, mixedControls, noop, vals;
    noop = function() {};
    a = Controls.getValidations();
    a.radio = noop;
    b = Controls.getValidations();
    equal(b.radio === noop, false, "Can't modify controlValidations directly.");
    c = Controls.getValidations();
    c.noop = noop;
    d = Controls.getValidations();
    equal("noop" in d, false, "Can't add controlValidations directly.");
    Controls.addValidation("noop", noop);
    e = Controls.getValidations();
    equal("noop" in e, true, "Can add controlValidations through addValidation()");
    mixedControls = Controls("#mixed-controls");
    equal(mixedControls.constructor, Controls.init, "ControlCollection constructor is exposed as Controls.init");
    equal(Object.getPrototypeOf(mixedControls), Controls.init.prototype, "ControlCollection prototype is exposed as Controls.init.prototype");
    equal(mixedControls instanceof Controls.init, true, "instances of ControlCollection pass instanceof with Controls.init");
    Controls.init.prototype.newCollectionMethod = function() {
      return true;
    };
    equal(mixedControls.newCollectionMethod(), true, "Methods added to Controls.init.prototype are avaialble to ControlCollection instances");
    vals = mixedControls.value();
    equal(vals.constructor, Controls.valueInit, "ValueObject constructor is exposed as Controls.valueInit");
    equal(Object.getPrototypeOf(vals), Controls.valueInit.prototype, "ValueObject prototype exposed as Controls.valueInit.prototype.");
    equal(vals instanceof Controls.valueInit, true, "instances of ValueObject pass instanceof with Controls.valueInit");
    Controls.valueInit.prototype.newValueMethod = function() {
      return true;
    };
    return equal(vals.newValueMethod(), true, "Methods added to Controls.valueInit.prototype are avaialble to ControlCollection instances");
  });

}).call(this);
